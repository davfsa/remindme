# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.29.0
#   sqlc-gen-better-python v0.4.4
"""Module containing queries from file queries.sql."""
from __future__ import annotations

__all__: collections.abc.Sequence[str] = (
    "Queries",
    "QueryResults",
)

import operator
import typing

if typing.TYPE_CHECKING:
    import asyncpg
    import asyncpg.cursor
    import collections.abc
    import datetime

    QueryResultsArgsType: typing.TypeAlias = int | float | str | memoryview | datetime.date | datetime.time | datetime.datetime | datetime.timedelta | None

    ConnectionLike: typing.TypeAlias = asyncpg.Connection[asyncpg.Record] | asyncpg.pool.PoolConnectionProxy[asyncpg.Record]

from remindme.db import models


ADD_DM_CHANNEL: typing.Final[str] = """-- name: AddDmChannel :exec
INSERT INTO dm_channels (user_id, channel_id)
VALUES ($1, $2)
"""

ADD_REMINDER_REFERENCE_MESSAGE: typing.Final[str] = """-- name: AddReminderReferenceMessage :exec
UPDATE reminders
SET reference_message_id=$1,
    reference_channel_id=$2,
    reference_guild_id=$3
WHERE id = $4
"""

CREATE_REMINDER: typing.Final[str] = """-- name: CreateReminder :one
INSERT INTO reminders (user_id, description, expire_at)
VALUES ($1, $2, $3)
RETURNING id, user_id, description, expire_at, reference_message_id, reference_channel_id, reference_guild_id, handled
"""

CREATE_REMINDER_WITH_REFERENCE: typing.Final[str] = """-- name: CreateReminderWithReference :one
INSERT INTO reminders (user_id, description, expire_at, reference_message_id, reference_channel_id, reference_guild_id)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, description, expire_at, reference_message_id, reference_channel_id, reference_guild_id, handled
"""

DELETE_REMINDER: typing.Final[str] = """-- name: DeleteReminder :exec
DELETE
FROM reminders
WHERE id = $1
"""

GET_DM_CHANNEL_FOR_USER: typing.Final[str] = """-- name: GetDmChannelForUser :one
SELECT channel_id
FROM dm_channels
WHERE user_id = $1
"""

GET_EXPIRED_REMINDERS: typing.Final[str] = """-- name: GetExpiredReminders :many
SELECT id, user_id, description, expire_at, reference_message_id, reference_channel_id, reference_guild_id, handled
FROM reminders
WHERE expire_at < NOW()
  AND handled = FALSE
"""

GET_HANDLED_REMINDERS: typing.Final[str] = """-- name: GetHandledReminders :many
SELECT id, user_id, description, expire_at, reference_message_id, reference_channel_id, reference_guild_id, handled
FROM reminders
WHERE handled = TRUE
  AND expire_at < $1
"""

GET_REMINDER: typing.Final[str] = """-- name: GetReminder :one
SELECT id, user_id, description, expire_at, reference_message_id, reference_channel_id, reference_guild_id, handled
FROM reminders
WHERE id = $1
"""

MARK_REMINDER_AS_HANDLED: typing.Final[str] = """-- name: MarkReminderAsHandled :exec
UPDATE reminders
SET handled = TRUE
WHERE id = $1
"""

RESCHEDULE_REMINDER: typing.Final[str] = """-- name: RescheduleReminder :one
UPDATE reminders
SET handled   = FALSE,
    expire_at = $1
WHERE id = $2
RETURNING id, user_id, description, expire_at, reference_message_id, reference_channel_id, reference_guild_id, handled
"""


T = typing.TypeVar("T")


class QueryResults(typing.Generic[T]):
    """Helper class that allows both iteration and normal fetching of data from the db.

    Parameters
    ----------
    conn
        The connection object of type `ConnectionLike` used to execute queries.
    sql
        The SQL statement that will be executed when fetching/iterating.
    decode_hook
        A callback that turns an `asyncpg.Record` object into `T` that will be returned.
    *args
        Arguments that should be sent when executing the sql query.

    """

    __slots__ = ("_args", "_conn", "_cursor", "_decode_hook", "_iterator", "_sql")

    def __init__(
        self,
        conn: ConnectionLike,
        sql: str,
        decode_hook: collections.abc.Callable[[asyncpg.Record], T],
        *args: QueryResultsArgsType,
    ) -> None:
        """Initialize the QueryResults instance."""
        self._conn = conn
        self._sql = sql
        self._decode_hook = decode_hook
        self._args = args
        self._cursor: asyncpg.cursor.CursorFactory[asyncpg.Record] | None = None
        self._iterator: asyncpg.cursor.CursorIterator[asyncpg.Record] | None = None

    def __aiter__(self) -> QueryResults[T]:
        """Initialize iteration support for `async for`.

        Returns
        -------
        QueryResults[T]
            Self as an asynchronous iterator.
        """
        return self

    def __await__(
        self,
    ) -> collections.abc.Generator[None, None, collections.abc.Sequence[T]]:
        """Allow `await` on the object to return all rows as a fully decoded sequence.

        Returns
        -------
        collections.abc.Sequence[T]
            A sequence of decoded objects of type `T`.
        """
        async def _wrapper() -> collections.abc.Sequence[T]:
            result = await self._conn.fetch(self._sql, *self._args)
            return [self._decode_hook(row) for row in result]
        return _wrapper().__await__()

    async def __anext__(self) -> T:
        """Yield the next item in the query result using an asyncpg cursor.

        Returns
        -------
        T
            The next decoded result.

        Raises
        ------
        StopAsyncIteration
            When no more records are available.
        """
        if self._cursor is None or self._iterator is None:
            self._cursor = self._conn.cursor(self._sql, *self._args)
            self._iterator = self._cursor.__aiter__()
        try:
            record = await self._iterator.__anext__()
        except StopAsyncIteration:
            self._cursor = None
            self._iterator = None
            raise
        return self._decode_hook(record)


class Queries:
    """Queries from file queries.sql.

    Parameters
    ----------
    conn : ConnectionLike
        The connection object used to execute queries.

    """

    __slots__ = ("_conn",)

    def __init__(self, conn: ConnectionLike) -> None:
        """Initialize the instance using the connection."""
        self._conn = conn

    @property
    def conn(self) -> ConnectionLike:
        """Connection object used to make queries.

        Returns
        -------
        ConnectionLike

        """
        return self._conn

    async def add_dm_channel(self, *, user_id: int, channel_id: int) -> None:
        """Execute SQL query with `name: AddDmChannel :exec`.

        ```sql
        INSERT INTO dm_channels (user_id, channel_id)
        VALUES ($1, $2)
        ```

        Parameters
        ----------
        user_id : int
        channel_id : int

        """
        await self._conn.execute(ADD_DM_CHANNEL, user_id, channel_id)

    async def add_reminder_reference_message(self, *, reference_message_id: int | None, reference_channel_id: int | None, reference_guild_id: int | None, id_: int) -> None:
        """Execute SQL query with `name: AddReminderReferenceMessage :exec`.

        ```sql
        UPDATE reminders
        SET reference_message_id=$1,
            reference_channel_id=$2,
            reference_guild_id=$3
        WHERE id = $4
        ```

        Parameters
        ----------
        reference_message_id : int | None
        reference_channel_id : int | None
        reference_guild_id : int | None
        id_ : int

        """
        await self._conn.execute(ADD_REMINDER_REFERENCE_MESSAGE, reference_message_id, reference_channel_id, reference_guild_id, id_)

    async def create_reminder(self, *, user_id: int, description: str, expire_at: datetime.datetime) -> models.Reminder | None:
        """Fetch one from the db using the SQL query with `name: CreateReminder :one`.

        ```sql
        INSERT INTO reminders (user_id, description, expire_at)
        VALUES ($1, $2, $3)
        RETURNING id, user_id, description, expire_at, reference_message_id, reference_channel_id, reference_guild_id, handled
        ```

        Parameters
        ----------
        user_id : int
        description : str
        expire_at : datetime.datetime

        Returns
        -------
        models.Reminder
            Result fetched from the db. Will be `None` if not found.

        """
        row = await self._conn.fetchrow(CREATE_REMINDER, user_id, description, expire_at)
        if row is None:
            return None
        return models.Reminder(id=row[0], user_id=row[1], description=row[2], expire_at=row[3], reference_message_id=row[4], reference_channel_id=row[5], reference_guild_id=row[6], handled=row[7])

    async def create_reminder_with_reference(self, *, user_id: int, description: str, expire_at: datetime.datetime, reference_message_id: int | None, reference_channel_id: int | None, reference_guild_id: int | None) -> models.Reminder | None:
        """Fetch one from the db using the SQL query with `name: CreateReminderWithReference :one`.

        ```sql
        INSERT INTO reminders (user_id, description, expire_at, reference_message_id, reference_channel_id, reference_guild_id)
        VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING id, user_id, description, expire_at, reference_message_id, reference_channel_id, reference_guild_id, handled
        ```

        Parameters
        ----------
        user_id : int
        description : str
        expire_at : datetime.datetime
        reference_message_id : int | None
        reference_channel_id : int | None
        reference_guild_id : int | None

        Returns
        -------
        models.Reminder
            Result fetched from the db. Will be `None` if not found.

        """
        row = await self._conn.fetchrow(CREATE_REMINDER_WITH_REFERENCE, user_id, description, expire_at, reference_message_id, reference_channel_id, reference_guild_id)
        if row is None:
            return None
        return models.Reminder(id=row[0], user_id=row[1], description=row[2], expire_at=row[3], reference_message_id=row[4], reference_channel_id=row[5], reference_guild_id=row[6], handled=row[7])

    async def delete_reminder(self, *, id_: int) -> None:
        """Execute SQL query with `name: DeleteReminder :exec`.

        ```sql
        DELETE
        FROM reminders
        WHERE id = $1
        ```

        Parameters
        ----------
        id_ : int

        """
        await self._conn.execute(DELETE_REMINDER, id_)

    async def get_dm_channel_for_user(self, *, user_id: int) -> int | None:
        """Fetch one from the db using the SQL query with `name: GetDmChannelForUser :one`.

        ```sql
        SELECT channel_id
        FROM dm_channels
        WHERE user_id = $1
        ```

        Parameters
        ----------
        user_id : int

        Returns
        -------
        int
            Result fetched from the db. Will be `None` if not found.

        """
        row = await self._conn.fetchrow(GET_DM_CHANNEL_FOR_USER, user_id)
        if row is None:
            return None
        return row[0]

    def get_expired_reminders(self) -> QueryResults[models.Reminder]:
        """Fetch many from the db using the SQL query with `name: GetExpiredReminders :many`.

        ```sql
        SELECT id, user_id, description, expire_at, reference_message_id, reference_channel_id, reference_guild_id, handled
        FROM reminders
        WHERE expire_at < NOW()
          AND handled = FALSE
        ```

        Returns
        -------
        QueryResults[models.Reminder]
            Helper class that allows both iteration and normal fetching of data from the db.

        """
        def _decode_hook(row: asyncpg.Record) -> models.Reminder:
            return models.Reminder(id=row[0], user_id=row[1], description=row[2], expire_at=row[3], reference_message_id=row[4], reference_channel_id=row[5], reference_guild_id=row[6], handled=row[7])
        return QueryResults[models.Reminder](self._conn, GET_EXPIRED_REMINDERS, _decode_hook)

    def get_handled_reminders(self, *, expire_at: datetime.datetime) -> QueryResults[models.Reminder]:
        """Fetch many from the db using the SQL query with `name: GetHandledReminders :many`.

        ```sql
        SELECT id, user_id, description, expire_at, reference_message_id, reference_channel_id, reference_guild_id, handled
        FROM reminders
        WHERE handled = TRUE
          AND expire_at < $1
        ```

        Parameters
        ----------
        expire_at : datetime.datetime

        Returns
        -------
        QueryResults[models.Reminder]
            Helper class that allows both iteration and normal fetching of data from the db.

        """
        def _decode_hook(row: asyncpg.Record) -> models.Reminder:
            return models.Reminder(id=row[0], user_id=row[1], description=row[2], expire_at=row[3], reference_message_id=row[4], reference_channel_id=row[5], reference_guild_id=row[6], handled=row[7])
        return QueryResults[models.Reminder](self._conn, GET_HANDLED_REMINDERS, _decode_hook, expire_at)

    async def get_reminder(self, *, id_: int) -> models.Reminder | None:
        """Fetch one from the db using the SQL query with `name: GetReminder :one`.

        ```sql
        SELECT id, user_id, description, expire_at, reference_message_id, reference_channel_id, reference_guild_id, handled
        FROM reminders
        WHERE id = $1
        ```

        Parameters
        ----------
        id_ : int

        Returns
        -------
        models.Reminder
            Result fetched from the db. Will be `None` if not found.

        """
        row = await self._conn.fetchrow(GET_REMINDER, id_)
        if row is None:
            return None
        return models.Reminder(id=row[0], user_id=row[1], description=row[2], expire_at=row[3], reference_message_id=row[4], reference_channel_id=row[5], reference_guild_id=row[6], handled=row[7])

    async def mark_reminder_as_handled(self, *, id_: int) -> None:
        """Execute SQL query with `name: MarkReminderAsHandled :exec`.

        ```sql
        UPDATE reminders
        SET handled = TRUE
        WHERE id = $1
        ```

        Parameters
        ----------
        id_ : int

        """
        await self._conn.execute(MARK_REMINDER_AS_HANDLED, id_)

    async def reschedule_reminder(self, *, expire_at: datetime.datetime, id_: int) -> models.Reminder | None:
        """Fetch one from the db using the SQL query with `name: RescheduleReminder :one`.

        ```sql
        UPDATE reminders
        SET handled   = FALSE,
            expire_at = $1
        WHERE id = $2
        RETURNING id, user_id, description, expire_at, reference_message_id, reference_channel_id, reference_guild_id, handled
        ```

        Parameters
        ----------
        expire_at : datetime.datetime
        id_ : int

        Returns
        -------
        models.Reminder
            Result fetched from the db. Will be `None` if not found.

        """
        row = await self._conn.fetchrow(RESCHEDULE_REMINDER, expire_at, id_)
        if row is None:
            return None
        return models.Reminder(id=row[0], user_id=row[1], description=row[2], expire_at=row[3], reference_message_id=row[4], reference_channel_id=row[5], reference_guild_id=row[6], handled=row[7])
